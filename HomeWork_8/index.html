<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HW_8</title>
</head>
<body>
    <script>
    // Задание 1

    // По всей видимости, замыкания можно и нужно применять в больших библиотеках. Таких, как jQuery, чтобы переменные не "засоряли" глобальное пространство и были видны только функциям самой библиотеки.     

    // Задание 2

        if (!("a" in window)) {
            var a = 1; 
        }
        alert(a); 
        // Выведет: Undefined. Сначала объявляется переменная "a", затем инструкция if говорит: «Если переменная a не объявлена, то инициализируем ее значением a = 1». Такое условие никогда не может быть истиным, поэтому переменная "a" остается со своим значением по умолчанию - undefined.


        var b = function a(x) {
            x && a(--x);
        };
        alert(a); 
        // Выведет: Undefined. Переменная "a" не определена. Переменной "b" присвоили функцию "a(x)", функция не вызыввается.


        function a(x) {
            return x * 2;
        }
        var a;
        alert(a); 
        // Объявление функции превалирует над объявлением переменной, если нет инициализации. В этом случае нет инициализации, поэтому выведется исходный код функции.


        function b(x, y, a) {
            arguments[2] = 10;
            alert(a);
        }
        b(1, 2, 3); 
        // Выведет: 10. В функции "b", которую мы вызываем с аргументами 1, 2, 3. Должно выводить 3, но т.к. внутри функции переопределятся псевдомассив аргументов "arguments[2]" на 10. Дальше выводится агрумент "a", который уже переопределен на 10, вместо входящего значения 3.


        function a() {
            alert(this);
        }
        a.call(null);  
        // Выведет: объект Window. Если this имеет значение NULL или undefined, вызываемой функции передается глобальный объект как это значение. Поэтому всегда, когда null передается call() (или apply ()) он по умолчанию использует глобальный объект, которым является объект Window.
    </script>
</body>
</html> 